# Базовые типы тензоров

## Реализованные типы

### 1. Vector (Одномерный тензор)

```go
type Vector []float64
```

**Назначение**: Представление одномерных массивов данных (векторов).

**Особенности**:
- Простой слайс float64
- Нативная производительность Go
- Используется для представления признаков, весов одного слоя, и т.д.

**Пример использования**:
```go
v := Vector{1.0, 2.0, 3.0, 4.0}
```

---

### 2. Matrix (Двумерный тензор)

```go
type Matrix struct {
    Data []float64
    Rows int
    Cols int
}
```

**Назначение**: Представление двумерных массивов данных (матриц).

**Особенности**:
- **Row-major хранение**: Элементы одной строки располагаются последовательно в памяти
- **Индексация**: `Data[row*Cols + col]` для доступа к элементу (row, col)
- **Кэш-локальность**: Row-major порядок обеспечивает лучшую производительность благодаря последовательному доступу к памяти

**Пример использования**:
```go
// Создание матрицы 2x3:
// [[1, 2, 3],
//  [4, 5, 6]]
m := Matrix{
    Data: []float64{1, 2, 3, 4, 5, 6},
    Rows: 2,
    Cols: 3,
}

// Доступ к элементу (1, 2) - это значение 6
value := m.Data[1*m.Cols + 2]  // = m.Data[5] = 6.0
```

---

### 3. Tensor (N-мерный тензор)

```go
type Tensor struct {
    Data    []float64
    Shape   []int
    Strides []int
}
```

**Назначение**: Универсальное представление многомерных массивов любой размерности.

**Поля**:
- `Data` - плоский массив всех элементов тензора
- `Shape` - размеры по каждой оси (например, [2, 3, 4] для тензора 2x3x4)
- `Strides` - шаги для доступа к элементам по каждой оси

**Особенности Strides**:

Strides указывают, сколько элементов нужно пропустить в линейном буфере `Data`, чтобы перейти к следующему элементу по данной оси.

**Пример вычисления Strides**:

Для тензора с `Shape = [2, 3, 4]`:
- Strides[2] = 1 (шаг по последней оси)
- Strides[1] = 4 (шаг по средней оси: нужно пропустить 4 элемента)
- Strides[0] = 12 (шаг по первой оси: нужно пропустить 3*4 = 12 элементов)

**Формула индексации**:
```
index = i₀*Strides[0] + i₁*Strides[1] + i₂*Strides[2] + ...
```

**Преимущества Strides**:
1. **Эффективное транспонирование**: Можно изменить порядок осей, просто переставив Strides и Shape, без копирования данных
2. **Работа с подтензорами**: Можно создать view на часть тензора без выделения новой памяти
3. **Гибкость**: Один и тот же буфер данных может представлять разные виды тензора

**Пример использования**:
```go
// Тензор 2x3x4
t := Tensor{
    Data:    make([]float64, 24),  // 2*3*4 = 24 элемента
    Shape:   []int{2, 3, 4},
    Strides: []int{12, 4, 1},
}

// Доступ к элементу [1, 2, 3]:
index := 1*12 + 2*4 + 3*1  // = 12 + 8 + 3 = 23
value := t.Data[index]
```

---

## Технические термины

### Row-major порядок

Способ хранения многомерных массивов в памяти, при котором элементы последней размерности (столбцы для матриц) располагаются последовательно.

**Преимущества**:
- Стандартный подход в Go, C, Python (NumPy по умолчанию)
- Лучшая кэш-локальность при обходе по строкам
- Последовательный доступ к памяти

**Альтернатива**: Column-major (используется в Fortran, MATLAB)

### Strides (шаги)

Массив целых чисел, определяющий смещение в линейном буфере для перехода к следующему элементу по каждой оси.

**Вычисление для row-major**:
```go
func calculateStrides(shape []int) []int {
    strides := make([]int, len(shape))
    stride := 1
    for i := len(shape) - 1; i >= 0; i-- {
        strides[i] = stride
        stride *= shape[i]
    }
    return strides
}
```

**Пример**:
- Shape: [3, 4, 5]
- Strides: [20, 5, 1]

**Применение**:
1. Транспонирование без копирования
2. Срезы (slicing) тензоров
3. Изменение формы (reshape) с сохранением данных

